# "완벽한 대응법이 없다" 버퍼 오버플로우 공격의 이해

원문보기:
https://www.itworld.co.kr/news/142560#csidxd5d729cfb409baf9f149a5ceff87cd4 

- 버퍼 오버플로우(Buffer Overflow) 또는 오버런(Overrun)은 일종의 메모리 안전 문제이다. 프로그램이 할당된 고정 길이(Fixed-length) 메모리 버퍼의 한계를 제대로 확인하지 않고 보유할 수 있는 것보다 많은 데이터를 쓰는 경우다. 이로 인해 데이터가 인접 메모리 공간으로 넘쳐서(overflow) 그곳에 있는 정보를 덮어쓰게 되고, 종종 충돌이나 악용 가능한 상태를 유발한다. 
 
- 버퍼 오버플로우는 임의로 악성 코드를 실행하는 가장 오래되고 흔한 취약점 공격 방법 중 하나다. C/C++ 프로그래밍 언어로 작성된 애플리케이션은 다른 언어보다 이러한 코드 오류의 가능성이 높다. 이를 피하기 위해 개발자 커뮤니티는 안전한 코딩 관행을 만들었으며, 주요 소프트웨어 업체는 이를 안전한 개발 수명 주기의 일부로 채택했다.
 
### 점점 늘어나는 버퍼 오버플로우 취약점
- 2014년에는 'Heartbleed'로 알려진 위협 때문에 수억 명의 사용자가 SSL 소프트웨어의 버퍼 오버플로 취약점으로 인해 공격에 노출되었습니다.

- 2019년 9월, 소프트웨어 취약점 목록(Common Weakness Enumeration, CWE) 카탈로그를 작성하는 마이터 코퍼레이션(Mitre Corporation)은 ‘가장 위험한 소프트웨어 오류 25개’를 발표했다. 그 중에서도 최악의 오류는 “CWE-119: 메모리 버퍼의 한계 내에서 이뤄지는 운영에 제대로 된 제한을 걸지 못해서 생기는 오류”였다. 버퍼 오버플로우와 한계를 벗어난 읽기를 포함하는 더 큰 클래스의 버퍼 처리 오류다. 

- 이 자료를 보면 버퍼 오버플로우를 없애기 위한 수년의 노력에도 불구하고 여전히 최고 위험 순위를 유지하고 있음을 알 수 있다. 마이터가 2011년 이후 가장 위험한 소프트웨어 오류 25개를 업데이트한 것은 이번이 처음이다. 이 순위는 2017년과 2018년에 걸쳐 관찰된 미 국토안보부 산하의 NVD(National Vulnerabilities Database)의 취약점 빈도와 평균 심각도를 결합한 새로운 점수 공식을 기반으로 했다. 따라서 이 목록은 특정 시점에 특정 위치에 발생하는 취약점(유병률)과 그로 인해 발생하는 위험에 따른 특정 유형의 약점과 관련된 전반적인 위험을 반영했다고 볼 수 있다.

- 버퍼 오버플로우가 다시 주목받는 이유는 또 있다. 지난 몇 년간의 연구에 따르면 시장에서의 입지가 확고한 업체의 최신 데스크톱 애플리케이션에 비해 코드 품질이 낮은 사물인터넷(IoT) 기기가 증가하고 있기 때문이다. 임베디드 시스템의 펌웨어는 오랫동안 지속적으로 버퍼 오버플로우 문제투성이였으며 이런 모호한 코드 기반은 대개 주요 정밀검사를 받지 않아서 몇 년 동안 큰 개선이 없었다. 같은 기간 인터넷, 비즈니스 네트워크, 가정으로 이러한 기기가 계속 퍼져나가고 있다.
 
### 대표적인 버퍼 오버플로우 해킹 사례
- 버퍼 오버플로우는 공격자가 덮어쓴 메모리 공간을 대상 버퍼 외부에서 제어하고 함수 포인터를 악의적인 코드로 리디렉션하는 경우 무단 코드 실행으로 이어질 수 있기 때문에 일반적으로 심각도 순위가 높다. 임의 코드를 실행할 수 없는 경우에도 버퍼 오버플로우로 인해 종종 충돌이 발생하고 애플리케이션의 가용성과 처리하는 프로세스에 영향을 주는 서비스 거부(Denial of Service, DoS) 조건이 발생한다. 이는 특히 지속적인 가용성이 필요한 서버에서 치명적이다.

- 경우에 따라 공격자는 버퍼 오버플로우를 사용해 애플리케이션 메모리의 중요 설정을 덮어쓸 수도 있다. 예를 들어 사용자가 관리자인지 여부를 나타내는 플래그를 덮어쓸 수 있다. 이는 애플리케이션과 잠재적으로 시스템 자체의 맥락에서 권한 상승으로 이어질 수 있다. 

- 마지막으로 버퍼 한계(경계)를 잘못 처리하면 공격자가 버퍼 외부의 데이터를 덮어쓰지 않고 읽을 수 있으므로 민감한 정보가 공개될 수 있다. 이를 범위를 벗어난 읽기라고 한다. 일반적인 버퍼 오버플로우와는 다르지만, 범위를 벗어난 읽기는 동일한 범주의 코딩 오류에 속한다. 범위를 벗어난 읽기는 공격자가 다른 취약점을 악용하는데 도움이 되는 정보를 얻기 위해 사용할 수 있다. 예를 들어 랜덤 메모리 주소 체계인 ASLR(Address Space Layout Randomization)과 같은 커널 악용 방지 기술로 보호되는 메모리 주소를 공개하는데 사용될 수 있다. 
 
### 버퍼 플로우를 방지하는 방법
- 버퍼 오버플로우는 프로그래밍 오류의 결과이다. 따라서 이를 방지하는 가장 좋은 방법은 개발자가 오류를 피하도록 교육하는 것이다. 보안 코딩 인증 프로그램뿐만 아니라, 다양한 보안 코딩 가이드, 서적을 참고하는 것도 버퍼 오버플로우를 해결하는 데 도움이 된다. CERT 코디네이션 센터(CERT Coordination Center)와 카네기 멜론 대학의 소프트웨어 공학 연구소는 C와 C++을 비롯한 여러 프로그래밍 언어에 대한 코딩 표준을 개발했다. 

- 버퍼 오버플로우를 방지하는 자동화된 방법도 있다. 메모리 안전 프로그래밍 언어나 프레임워크, 버퍼 오버플로우를 일으키기 쉬운 함수에 대한 안전한 버전을 제공하는 라이브러리를 사용하는 것이 대표젹이다. 또한, 개발자가 ASLR과 위치 독립 실행 파일(position-independent executables, PIE) 같은 기능을 사용하는 애플리케이션을 만들어 버퍼 오버플로우의 잠재적 영향을 제한할 수 있다. 이밖에 컴파일러 플래그 및 확장을 사용하면, 마이크로소프트 비주얼 스튜디오의 /GS 플래그, 레드햇, 스택가드(Stackguard), 프로폴리스(ProPolice)가 추가한 FORTIFY_SOURCE GCC 플래그와 같은 오류를 탐지할 수 있다.

- 그러나 불행히도 이러한 솔루션 중 완벽한 보호를 제공하는 것은 없다. 내외부 보안팀이 함께 주기적으로 코드를 검토하고 애플리케이션 보안 테스트를 수행해야 하는 이유다. 퍼저(fuzzers)와 같은 도구를 자동화된 테스팅 워크플로우에 통합하는 것도 중요하다. editor@itworld.co.kr

원문보기:
https://www.itworld.co.kr/news/142560#csidxb937dc1fff7a615bd5e65d42aa0a07c 

- "버퍼 오버플로우"는 어떻게 이루어지는가? 버퍼 오버플로우의 정확한 동작원리를 이해하기 위해서는 프로그램에 의해 데이터가 어떻게 저장되는가를 우선 이해해야 한다. 하나의 프로그램은 수많은 서브 루틴들로 구성되는데 이런 서브 루틴이 프로그램에 의해 호출될 때, 함수 변수와 서브 루틴의 복귀 주소(return address) 포인터를 스택(stack)이라는 논리적 데이터 구조에 저장하게 된다. 스택은 실행중인 프로그램이 필요로 하는 정보를 저장하는 메모리 영역이다. 서브 루틴이 종료될 때 운영체제는 그것을 호출한 프로그램에 제어권을 반환해야 하기 때문에, 복귀 포인터를 통해서 프로그램이 서브 루틴의 실행을 마치고 나서 되돌아갈 주소를 가리키게 된다. 버퍼는 할당된 메모리 공간의 높은 주소에서 낮은 주소로 채워지며, 스택 영역에 마지막으로 들어가 데이터가 제일 먼저 빠져 나오는 LIFO(Last in, First out) 특정을 가지고 있다. 이런 LIFO 특성에 의해 가장 먼저 들어가 것(복귀 포인터)이 스택에서 가장 나중에 제거된다는 것을 기억해야 한다. 서브 루틴이 실행을 마치면 가장 나중에 행해지는 것은 복귀 포인터를 스택에서 제거하여 서브 루틴을 호출한 함수로 반환하는 것인데, 만약 이 포인터가 사용되지 않는다면 서브 루틴이 실행을 마쳤을 때 프로그램은 더 이상 어디로 진행해야 할지를 알 수 없을 것이다. 포인터(pointer)는 메모리의 위치를 저장하는 변수이다. 프로그램 실행을 위한 목적으로 다른 코드로 이동할 때 어디에서 떠났는지를 기억하기 위해 포인터를 사용해야 하며, 만약 포인터를 사용하지 않는다면 서브 루틴의 실행이 끝나고 어디로 돌아와야 할지를 알 수 없을 것이다. 이제 스택을 조작하게 되면 어떤 일이 일어나는지를 살펴 보겠다. 프로그램이 변수의 할당된 공간에 저장될 데이터의 크기를 검사하지 않고 크기에 제한을 두지 않는다면, 변수 공간은 넘치게 될 것이다. 즉, 버퍼에 오버플로우가 발생하면 저장된 데이터는 인접한 변수 영역도 침범할 것이며 결국에는 포인터 영역까지 침범하게 될 것이다. 해커는 이러한 데이터의 길이와 내용을 적절히 조정함으로써 버퍼 오버플로우를 일으키고 운영체제의 스택을 붕괴시켜 특정 코드가 실행되도록 한다. 해커가 보낸 데이터는 대개의 경우 특정 시스템에서 실행될 수 있는 기계어 코드와 복귀 포인터에 저장될 새로운 주소로 구성되어 있으며, 복귀 포인터에 저장될 새로운 주소는 다시 메모리의 스택 영역을 가리켜서 프로그램이 서브 루틴에서 반환될 때 해커가 작성한 명령어를 실행하게 되는 것이다. 이때 고려해야 할 것은 공격 대상이 되는 프로그램이 무엇이든 간에 해커가 공격 코드는 프로그램이 실행되고 있는 권한으로 실행될 것이라는 점이다. 따라서 해커는 공격을 성공시켰을 경우에 시스템에 대한 최상위 권한을 얻기 위해, root 또는 administrator 권한으로 실행 중인 프로그램을 공격 대상으로 삼을 것이다. 이론상으로는 매우 직관적인 것 같지만 실제로 이 공격을 실행하는 것은 간단한 작업이 아니다. 하지만 이런 과정이 어떻게 이뤄지는지 제대로 이해하지 못 하는 스크립트 키디(script kiddie)도 쉽게 공개된 공격 코드를 이용하여 버퍼 오버플로우 공격을 시도할 수 있으니 보안 관리자들에게 보다 많은 업무를 주는 상황이라고 할 수 있다.


# 3.3 Buffer Overflow/Underflow

## 3.3.0 실제사례

## 3.3.1 정의와 원리
**정의**
- 버퍼 오버플로우(또는 버퍼 오버플로)는 프로그래밍에서 발생하는 보안 취약점 중 하나입니다. 프로그램이 할당된 고정 길이(Fixed-length) 메모리 버퍼의 한계를 제대로 확인하지 않고 범위를 초과하여 데이터를 쓰거나 덮어쓰는 것을 말합니다. 주로 C 및 C++과 같은 저수준 프로그래밍 언어로 작성된 프로그램에서 발생하며 메모리 관리에 대한 책임이 개발자에게 있기 때문에 발생할 가능성이 높습니다. 이와 반대로 버퍼 언더플로우(또는 버퍼 언더플로)는 버퍼 오버플로우의 반대 개념으로 버퍼의 최소 경계보다 작은 범위에서 발생하는 보안 취약점입니다. 일반적으로 배열과 같은 버퍼는 정해진 크기를 가지는데, 배열의 최소 인덱스보다 작은 인덱스에 데이터를 쓰려고 할 때 발생합니다. 이러한 상황에서는 주로 메모리 무결성이 손상되거나 잘못된 결과가 발생할 수 있습니다.

**원리**
- 버퍼 오버플로우 / 버퍼 언더플로우 공격의 원리는 다음과 같습니다.
    1. 해커는 취약한 프로그래밍 코드를 찾아냅니다. 취약한 프로그래밍 코드는 일반적으로 버퍼의 크기를 제대로 검사하지 않거나, 버퍼의 크기를 초과 또는 버퍼의 크기보다 작은 데이터를 입력받아도 안전하게 처리하지 못하는 코드를 말합니다.
    2. 해커는 취약한 프로그래밍 코드에 데이터의 길이와 내용을 적절히 조정하여 입력하는데 프로그램이 할당받은 버퍼의 양을 초과하거나 버퍼의 크기보다 작은 데이터를 입력합니다. 이런 방법을 통해 버퍼 오버플로우 또는 언더플로우를 일으키고 운영체제의 스택을 붕괴시킵니다.
    3. 해커는 버퍼 오버플로우 또는 언더플로우를 통해 새로운 코드를 삽입하거나 데이터를 조작할 수 있습니다. 이런 방법을 통해 악성코드를 실행하여 시스템을 제어하거나 데이터를 탈취할 수 있고, 시스템 장애를 일으킬 수 있습니다.

## 3.3.2 공격 유형

### **스택 오버플로 공격** - 가장 일반적인 유형의 버퍼 오버플로 공격으로, 스택에 위치한 버퍼에 할당된 것보다 더 많은 데이터를 쓸 때 발생한다. 스택 오버플로 공격은 스택 스매싱이라고 알려진 공격의 한 부분으로 고의적으로 유발되는데, 만약 영향을 받는 프로그램이 특정한 권한에서 실행되고 있거나 신뢰되지 않는 네트워크 호스트 또는 서버에서 데이터를 받게 되면 이곳에서 잠재적인 보안 취약점으로 작용될 수 있다. 스택 버퍼가 신뢰되지 않는 네트워크 호스트 또는 서버로부터 받은 데이터로 채워진다면 사용자는 실행가능한 코드를 실행중인 프로그램에 삽입하고 프로세스의 제어를 얻는 방식으로 공격할 수 있다. 

스택 버퍼 오버플로우(Stack Buffer Overflow)는 버퍼 오버플로우 공격의 한 유형으로, 스택 메모리 영역에서 발생하는 버퍼 오버플로우를 의미합니다. 스택은 함수 호출 시 지역 변수, 매개 변수 및 복귀 주소 등을 저장하는 데 사용되는 메모리 영역입니다. 따라서 스택 버퍼 오버플로우는 주로 함수 내부에서 배열 또는 버퍼를 사용할 때 발생합니다.

스택 버퍼 오버플로우 공격은 일반적으로 다음과 같은 단계를 거칩니다:

악성 공격자가 입력 데이터를 조작하여 프로그램에 대한 제어권을 획득하려고 합니다.
악성 공격자가 입력 데이터를 프로그램에 전달합니다.
프로그램은 입력 데이터를 처리하기 위해 해당 데이터를 스택에 저장합니다.
만약 프로그램이 적절한 검증 또는 경계 검사 없이 입력 데이터의 크기나 형식을 확인하지 않으면, 입력 데이터가 할당된 스택 영역을 초과하여 다른 중요한 정보(예: 복귀 주소)나 코드 영역을 덮어쓸 수 있습니다.
이러한 상황에서 악성 공격자가 임의의 코드 조각이나 악성 페이로드(malicious payload)를 제공하여 해당 위치에서 실행될 수 있는 제어권(control flow hijacking)을 얻으려 할 수 있습니다.
스택 버퍼 오버플로우 공격은 시스탬 크래시, 임의의 코드 실행, 권한 상승 등과 같은 심각한 결과를 초래할 수 있으며, 보안상 매우 위협적인 문제입니다.

스태크 보호 기법(Stack Protection Mechanisms)은 이러한 종류의 공격으로부터 시스탬과 소중한 데이터들을 보호하기 위해 개발되었습니다. 예를 들면 Canary 값(무결성 검사 값을 포함하는 보호 값을 추가), 스택 가드(Stack Guard), ASLR(Address Space Layout Randomization) 등이 있습니다. 이러한 기법들은 스택 메모리 구조와 복구 절차에 대해 추가적인 보호 계층을 도입하여 버그와 취약점 가능성 감소시켜줍니다.

개발자들과 보안 전문가들은 안전한 코딩 관례와 함께 입력값 검증 및 경계 검사 등의 방어 메커니즘을 준수하여 스택 버퍼 오버 풀공격으로부터 시스탬과 소중한 데이터들을 안전하게 지켜내기 위해 지속적인 주의와 대비조치가 필요합니다.

### **힙 오버플로 공격** - 힙 데이터 영역에서 발생하는 버퍼 오버플로의 한 종류이다. 힙 오버플로는 스택 기반 오버플로와는 다른 방식으로 익스플로잇 가능하다. 힙에서의 메모리는 런타임 시에 애플리케이션에 의해 동적으로 할당되며 일반적으로 프로그램 데이터를 포함한다. 익스플로잇은 애플리케이션이 링크드 리스트 포인터 같은 내부 구조체를 겹쳐쓰는 것 같이 이 데이터를 특정한 방식으로 오염시킴으로써 수행된다. 고전적인 힙 오버플로 기법은 동적 메모리 할당 연결(malloc 메타 데이터 같은)을 겹쳐쓰고 프로그램 함수 포인터를 겹쳐쓰기 위해 결과로 나온 포인터를 교환하는 기법이다. 옛날 버전의 리눅스에서의 전형적인 예시는 힙에서 두 버퍼가 각각 나란히 할당되고, 첫 번째 버퍼의 경계 외부에 쓰는 것이 두 번째 버퍼의 메타 데이터를 겹쳐쓰게되는 것이다. 두 번째 버퍼의 사용 비트를 0으로 설정하고 널 바이트들이 복사되게 하기 위해 작은 음수 값을 길이로 설정한 후에, 첫 번째 버퍼에서 프로그램이 free() 함수를 호출할 때 프로그램은 이 두 버퍼를 단일 버퍼로 통합하려는 시도를 할 것이다. 이 상황이 벌어지면 free될 버퍼는 이전에 할당된 버퍼의 첫 8 바이트에 포워드와 백이라는 두 포인터를 갖게 된다.

### **정수 오버플로 공격** - 정수 오버플로의 경우에는 산술 연산으로 인해 저장하려는 정수 유형에 비해 너무 큰 정수가 생성되며, 이로 인해 버퍼 오버플로가 발생할 수 있습니다.

### **유니코드 오버플로** - 유니코드 오버플로는 ASCII 문자를 예상하는 입력에 유니코드 문자를 삽입하여 버퍼 오버플로를 생성합니다.(ASCII와 유니코드는 컴퓨터가 텍스트를 표현할 수 있도록 하는 인코딩 표준입니다.예를 들어 문자 'a'는 ASCII에서 숫자 97로 표시됩니다.ASCII 코드는 서양 언어의 문자만 지원하지만, 유니코드는 지구상의 거의 모든 문자 언어의 문자를 생성할 수 있습니다.유니코드로 사용할 수 있는 문자가 훨씬 더 많으므로 유니코드 문자가 가장 큰 ASCII 문자보다 큰 경우가 많습니다).

## 3.3.3 대응 방법
- 스택 버퍼 오버플로를 억제하는 계획들이 개발되어 왔다. 이것들은 크게 세 카테고리로 분류될 수 있다.
    - 발생한 스택 버퍼 오버플로를 탐지하고 악의적인 코드로의 명령어 포인터 리다이렉션을 방지한다.
    - 직접적으로 스택 버퍼 오버플로를 탐지하지 않고, 악의적인 코드가 스택에서 실행되는 것을 방지한다.
    - 실행 가능한 코드를 찾는 것을 신뢰하지 못하게 메모리 공간을 랜덤화한다.

**스택 카나리스**
스택 카나리스는 악의적인 코드의 실행이 일어나기 전에 스택 버퍼 오버플로를 탐지하는데 사용된다. 이 방식은 프로그램 시작 시에 선택된 랜덤한 작은 정수를 스택 반환 포인터 전에 놓은 것이다. 대부분의 버퍼 오버플로는 낮은 곳에서 높은 곳으로 메모리 주소를 겹쳐쓰므로 반환 포인터를 겹쳐쓰기 위해서는 카나 값이 반드시 겹쳐써질 수 밖에 없다. 이 값은 루틴이 스택의 반환 주소를 사용하기 전에 바뀌었는지 검사된다.[2] 이 기법은 스택 버퍼 오버플로를 익스플로잇하는 난이도를 증가시키는데, 공격자가 스택의 다른 중요한 변수들을 오염시키는 것 같은 전통적이지 않은 방식으로 명령어 포인터의 제어를 얻게 하기 때문이다.[2]

**실행 불가능 스택**
스택 버퍼 오버플로 익스플로잇을 방지하는 다른 접근법으로 (스택에서의 실행을 불허하는) 스택 메모리 영역에 대한 정책을 강제하는 것이 있다(W^X, "Write XOR Execute"). 이것은 공격자가 메모리에서 실행 보호를 비활성화하거나 셸코드 페이로드를 메모리의 보호되지 않은 영역에 놓는 방식을 찾게 한다. 이 방식은 현재 더 유명해 졌는데, 대부분의 데스크탑 프로세서들에서 하드웨어가 실행 불가능 플래그를 지원하기 때문이다.

이 방식이 스택 버퍼 오버플로 취약점 공격을 실패하게 하는 좋은 접근법인 반면에 여전히 문제는 존재한다. 첫째, 셸코드를 힙 같은 보호되지 않은 메모리에 저장하는 방식을 찾기가 쉽다.[11]

이 방법이 아니더라도 다른 방식들도 존재한다. 가장 최악은 셸코드 생성을 위한 return-to-libc 공격 방식이다. 이 공격에서 악의적인 페이로드는 셸코드 없이, 하지만 적절한 콜 스택과 함께 스택을 로드해서 실행은 표준 라이브러리 호출들의 체인에 위치하게 된다.[12] 이것은 실행이 실제로는 스택 자체에 위치하지 않기 때문에 동작한다.

return-to-libc의 변형으로 반환 주소 시리즈들을 설치하는 반환 지향형 프로그래밍(ROP)이 있는데 이것들 각각은 현재의 프로그램 코드나 시스템 라이브러리 내에서 기계어 명령어들의 작은 시퀀스(return으로 끝나는)들을 실행한다. 반환 전에 각각 몇몇 간단한 레지스터 조작이나 비슷한 실행을 수행하고 같이 잇는 이러한 일명 가젯들은 공격자의 종료를 달성한다. 이것은 반환 명령어와 비슷하게 행동하는 명령어들을 익스플로잇 함으로써 심지어 "반환 없는" ROP를 사용할 수도 있다.[12]

**랜덤화**
코드를 데이터에서 분리하는 것 대신 다른 기법으로 실행 가능한 프로그램의 메모리 공간을 랜덤화하는 것이 있다. 공격자가 위치할 실행 코드를 어디에 위치시킬 지를 결정할 필요가 있기 때문에 실행 가능한 페이로드는 실행 가능한 스택과 함께 제공되거나 ret2libc 또는 ROP같은 코드 재사용을 사용해서 구성되는데, 메모리 레이아웃을 랜덤화하는 것은 공격자가 코드가 어디에 존재하는지를 알게 하는 것을 방어한다. 그러나 구현은 일반적으로 모든 것을 랜덤화하지는 않으며, 심지어 ASLR이 실행 불가 스택에 적용되더라도 주로 실행 파일 자체는 고정 주소에 로드되며 공격자는 메모리의 이 고정 영역을 사용할 수 있다. 그러므로 모든 프로그램들은 반드시 메모리의 영역까지 랜덤화되는 PIE(position-independent executables)와 함께 컴파일되어야 한다. 랜덤화의 엔트로피는 구현 마다 다르며 충분히 작은 엔트로피는 본질적으로 메모리 공간을 무차별 대입 공격하는 것에 대해 문제가 될 수 있다.

<br>

- 힙 오버플로를 방어하는 방식으로 세 종류가 있다. 여러 현대 운영 체제들은 세가지 모두의 구현 중 일부를 제공한다.
    - 일반적으로 NX 비트 같은 하드웨어 특징들을 통해 코드와 데이터를 분리함으로써 페이로드의 실행을 막는다
    - 힙이 고정된 오프셋에서 발견되지 못하게 난수화를 도입한다
    - 힙 매니저에 대한 분별력 있는 검사를 도입한다.

**GNU libc**
GNU libc는 2.3.6 버전부터 unlink를 호출할 때 포인터의 일관성을 검사하는 것 같이 힙 오버플로를 탐지하는 방어가 포함되었다. 그러나 이러한 방어들은 거의 즉시 공격 가능하다고 밝혀졌다.[2][3] 추가적으로 리눅스는 (비록 PaX가 몇 년 전에 더 나은 구현을 도입하였지만) 2005년 이후부터는 ASLR을 포함하였다. 또한 리눅스는 2004년부터는 NX 비트의 지원을 포함하였다.

**마이크로소프트**
마이크로소프트는 2003년부터 힙에 기반한 버퍼 오버플로에 대한 방어를 포함하였다. 이러한 완화는 안전한 링크해제와 힙 엔트리 헤더 쿠키가 있다. 윈도우의 최근 버전들은 일반적으로 대상이 되는 데이터 구조체들의 제거, 힙 엔트리 메타데이터 난수화, 함수 포인터 인코딩, 힙 오염의 종료 그리고 알고리즘 변이를 포함한다. 일반 데이터 실행 방어(DEP)와 ASLR 도 또한 이 공격을 완화시키는데 도움을 준다.[4]

## 정의

- 프로그램에서 정해진 버퍼의 크기를 초과하여 데이터를 쓸 때 발생하는 보안 취약점입니다. 이로 인해 공격자는 프로그램의 정상적인 동작을 방해하고, 임의의 코드를 실행하거나 민감한 정보를 노출 시킬 수 있습니다.

## 상세 설명

1. **원인**:
    - **입력 검증 부재**: 개발자가 사용자 입력의 길이를 검증하지 않아 발생합니다.
    - **버그와 오류**: 소프트웨어 개발 중에 발생하는 실수나 오류 때문에 발생할 수 있습니다.
2. **공격 유형**:
    - **Stack Overflow**: 스택 메모리 영역에 데이터를 너무 많이 쓰는 것입니다.
    - **Heap Overflow**: 힙 메모리 영역에 데이터를 너무 많이 쓰는 것입니다.
3. **결과**:
- **코드 실행**: 공격자는 버퍼 오버플로우를 이용해 임의의 코드를 실행할 수 있습니다.
- **시스템 충돌**: 과도한 데이터로 인해 시스템이 불안정해지거나 충돌할 수 있습니다.
- Buffer Overflow 공격은 메모리 손상, 프로그램 비정상 종류, 잘못된 동작 등을 일으킬 수 있으며, 보안 취약점으로 이용될 경우 악성 코드 실행이나 시스템 접근 권한 획득 등의 결과를 초래할 수 있습니다.

## 예방 및 방어 방법

1. **입력 검증**:
    - **길이 검증**: 입력 데이터의 길이를 검증하여 버퍼 오버플로우를 방지합니다.
    - **특수 문자 검증**: 특수 문자를 필터링하여 공격자가 특수 문자를 이용한 공격을 차단합니다.
2. **컴파일러 보안 기능 활용**:
    - **Stack Canaries**: 스택을 보호하기 위해 컴파일러에 의해 자동으로 삽입되는 코드 조각입니다.
    - **DEP(Data Execution Prevention)**: 메모리 영역에 데이터만 저장하도록 하고 코드 실행을 방지합니다.
3. **안전한 프로그래밍 기술 사용**:
    - **Bounds checking**: 배열의 인덱스가 유효한지 확인하여 메모리 누수와 오버플로우를 방지합니다.
    - **Safe Libraries**: 안전한 라이브러리 사용으로 오버플로우 발생 가능성을 줄입니다.
4. **코드 리뷰 및 테스팅**:
    - **정적 코드 분석**: 코드를 실행하지 않고 분석하여 보안 취약점을 찾는 방법입니다.
    - **퍼즈 테스팅**: 임의의, 예측 불가능한, 또는 무작위 입력을 사용하여 소프트웨어를 테스트합니다.
5. **정기적인 보안 업데이트 및 패치**:
    - **보안 업데이트**: 시스템과 소프트웨어의 최신 보안 업데이트를 적용합니다.
    - **패치 관리**: 취약점이 발견되면 적시에 패치를 적용하여 위협을 줄입니다.